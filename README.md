## 암호이론

> 기본적인 암호 관련 이론 정리

### 해시함수

```bash
    해시 함수란 주어진 데이터를 고정 길이의 불규칙적인 숫자로 변환하는 함수
    해시함수를 통해서 출력된 값을 해시 값이라고 한다.
    해시값은 숫자지만 16진수로 표기하는 경우가 많다.
    특징:
    
    1. 출력하는 값의 데이터 길이가 변경되지 않는다.
        출력되는 데이터의 길이는 함수에 따라 다르지만, SHA-1에서는 20byte 로 고정 된다.
        매우 큰 데이터를 입력해도, 매우 작은 데이터를 입력해도 해시 값의 데이터 길이는 동일하다.
    
    2. 입력이 동일하면 출력도 반드시 동일하다.

    3. 비슷한 데이터를 입력해도 1bit 라도 다른 데이터라면 출력이 크게 달라진다.
    4. 전혀 다른 데이터를 입력해도 동일한 해시 값이 나올 수 있는 경우가 낮은 확률이지만 존재한다.
            이것을 해시값 충돌이라 한다.
    5. 해시값으로부터 원 데이터를 역산하는것이 사실상 불가능 하다.
        데이터 입력과 출력의 흐름이 일방향으로 이루어지며, 이것은 암호화와 크게 다른 점이다.
    6. 해시값을 결정하는 계산이 비교적 간단하다.
    종류:
        해시 함수의 알고리즘에는 여러가지가 존재한다.
        최근에는 SHA-2 가 일반적으로 사용된다. (?)
```
### 공통키 암호 방식 (또는 대칭키)
```bash
    공통키 암호 방식은 암호화와 복호화에 동이한 키를 사용하는 암호방식이다.
    원리:
        Alice 가 Bob 에게 데이터를 전달 한다고 가정.
        Alice 가 Bob 에게 인터넷을 통해 중요한 메시지를 전달할 때 해당 메시지가 평문일 경우 제 3자에게 노출 될수있다.
        Alice 는 해당 메시지를 비밀키를 사용하여 암호화 한 후 Bob 에게 전달한다.
        Bob 은 Alice 에게서 받은 비밀키를 사용하여 복호화 한 후 볼 수 있다.
        제 3자는 해당 암호문을 획득하였다고 해도 비밀키를 모르기 때문에 복호화 하여 볼 수 없다.

        공통키 암호 방식에는
            시저암호, AES, DES, OTP 등 이 있다.
        
        문제점:
            Alice 와 Bob 이 직접 만난적이 없고 암호화에 사용된 비밀키를 Bob 이 모른다고 가정 해보자.
            Alice 는 인터넷을 통해 Bob 에게 인터넷을 통해 비밀키를 전달해야 한다.
            이때 제 3자가 비밀키를 획득할 경우 암호문을 복호화 하여 볼 수 있다.
            이와 같이 공통키 암호 방식에는 키 전달 문제가 있다. 이문제를 키배분 문제라고 하며 
            해결 방법으로는 '키 교환 프로토콜을 사용하는 방법' 과 '공개키 암호방식 또는 비대칭키' 두가지가 있다.
```
### 공개키 암호방식 
```bash
    공개키 암호방식은 암호화와 복호화에 서로 다른 키를 사용 하는 방식이다.
    암호화에 사용하는 키를 '공개키(public key)', 복호화에 사용하는 키를 '비밀키(private key)' 라고 한다.
    공통키 암호방식에 비해 공개키 암호 방식의 경우 암호화 및 복호화에 시간이 많이 소요 된다.
    공개키 암호방식에는 RSA 암호, 타원 곡선 암호 가 있다.

    원리:
        Alice 가 Bob에게 인터넷을 통해 데이터를 전송 한다고 가정.
        먼저 데이터를 받는 Bob 이 public key 와 private key 를 생성한다.
        Bob 은 Alice 에게 public key 를 전송 한다.
        Alice 는 Bob 에게서 받은 public key 를 사용하여 데이터를 암호화 한다.
        Alice 는 암호문을 Bob 에게 전송 한다.
        Bob 은 암호문을 private key 를 사용하여 복호화 한다.
        public key 와 암호문은 인터넷을 통해 전달 된다.
        여기서 제 3자가 암호문과 public Key 를 훔친다고 하여도 암호문을 복호화 할수 없다.
        즉 공통키 암호방식과 달리 공개키 암호 방식에서는 '키 분배 문제'가 발생하지 않는다.
        public key 는 다른 사람에게 노출 되어도 문제 없다.
        따라서 불특정 다수가 공개키를 생성한 Bob 에게 public key 를 사용하여 암호화한 데이터를 전송하면 해당 암호화된 데이터는 private key 를 소유한 Bob에의해서만 복호화가 가능 하다.
        * 비밀키 (private key) 는 절대로 노출해서는 안된다.
        즉 데이터를 전송하는 상대방 모두가 키를 가지고 있을 필요도 없다. (공개된 키이기때문에)
        public key 와 private key 를 생성한 자가 private key 만 노출 시키지 않으면 된다.

        문제점:
            1. 암호화 및 복호화에 시간이 많이 소요된다.
                상세한 데이터를 연속적으로 교환하는 구조에는 적합하지 않다.
                이러한 문제를 해결하려면 '하이브리드 암호 방식' 을 사용해야 한다.
            2. 공개키의 신뢰도에 문제가 있다.
                가령 제3자가 Bob 이생성한 public key 를 자신이 만든 public key 로 바꾸어 Alice 에게 전달하면 Alice 는 누가 작성한 public key 인지 알수가 없다. public key 에는 누가 작성한지를 표시하는 수단이 없다.
                따라서 Alice 가 받은 public key 가 바뀐것을 알수가 없어 제3자가 만은 public key 로 암호화 하여 암호화된 데이터를 전송 하게 된다.
                이것을 제 3자가 중간에서 가로채서 복호화 한 후 Bob 의 public key 로 다시 암호화 하여 Bob에게 전송하면 Bob 은 자신이 공개한 public key 로 암호화한 메시지이므로 아무런 의심없이 데이터를 복호화 하여 볼수 있게된다.
                이러한 공격을 'man-in-the-middle'공격이라고 한다.
                이러한 문제를 해결 하려면 '전자 인증서'를 사용해야 한다.

```

### 하이브리드 암호 방식 
```bash
    공통키 암호방식에는 '키 분배 문제'가 있다.
    공개키 암호방식에는 암복호화 처리 속도가 느리다는 단점이 존재한다.
    하이브리드 방식은 이 두가지 방식을 결합하여 위의 두가지 약점들을 보완 한다.

    하이브리드 암호 방법:
        데이터 암호화에는 처리속도가 빠른 공통키 암호 방식 사용.
        공통키 암호방식에서 사용하는 키는 키 분배가 불필요한 공개키 암호방식을 사용.
    
    원리:
        Alice 가 데이터를 암호화 하여 Bob 에게 인터넷을 통해 전송 하려고 한다.
        Alice 는 데이터 암호화에 사용하는 키를 안전하게 Bob에게 보내주어야 한다. 
        그러기 위해 먼저 Bob 이 공개키/개인키 한 쌍을 생성 하여 공개키를 전송 한다.(공개키는 공개되어도 상관 없음)
        Alice 는 Bob의 공개키를 사용하여데이터 암호화에 사용할 키를 암호화 하여 Bob에게 전송 한다.
        Bob은 전달 받은 키를 자신의  비밀키를 사용하여 복호화 한다. 복호화된 키는 Alice 가 추후 데이터를 암호화할때 사용하는 키이다.
        이로써 Alice 와 Bob 은 데이터 암호화에 사용할 키를 안전하게 획득 할수 있게 되며, 해당 키로 데이터를 암호화 하여 전송 및 복호화 할수있게 된다.
        즉 Alice와 bob 은 사전에 공통키 암호 방식에 사용하는 키를 공개키 암호방식으로 최초에 주고 받은 후 해당 키로 암복호화 할수있게 된다.

        이렇게 하이브리드 암호방식은 안정성과 속도를 모두 만족하게 된다.
        하이브리드 암호 방식은 SSL 프로토콜에서 사용 된다.

    
```

###  Diffie-Hellma(디피-헬먼) 키 교환법
```bash
    디피헬먼 키 교환법은 안전하게 키를 교환 하기 위한 기법
    출처: https://ko.wikipedia.org/wiki/디피-헬먼_키_교환

    원리:
        실제 응용에서는 안전을 위해 10 진수 수백 ~ 수천 자리 크기의 큰 소스를 사용한다.
        여기서는 설명을 위해 작은 크기의 소수를 사용한다.

        1. Alice 와 Bob 은 p=23,g=5 를 사용하기로 합의 한다. 
            이때 p, g 값은 공개된 정보이다.
        2. Alice 가 비밀정보를 전송하기 위해 임의의 정수 a=6 을 고른 후 , Bob에게 A=g^a mod p 를 전송 한다.
            이때 a 값은 Alice 만 알고 있어야한다.
            A=5^6 mod 23 => A = 8
        3. Bob은 임의의 정수 b=15를 고르고, Alice 에게 B=g^b mod p 를 전송 한다.
            이때 b 값은 Bob 만 알고 있어야 한다.
            B = 5^15 mod 23 => B = 19
        4. Alice 는 Bob 에게서 받은 B를 바탕으로 s=B^a mod p 를 계산한다.
            s=19^6 mod 23
            s=2
        5. Bob은 Alice 에게서 받은 A 를 바탕으로 s=A^b mod p를 계산한다.
            s=8^15 mod 23
            s = 2
        6. Alice 와 Bobd은 이제 비밀키 s=2 를 공유하게 되었다.

        여기서 p 가 충분히 클 경우, 외부에서 비밀키를 알아내기 위해 도청을 하는 도청자는 g^a 나 g^b 를 통해 s를 알아 낼 수 있는 가능성은 거의 없다고 본다.
        이후 데이터 통신은 공통키 암호를 이용해 통신을 암호화 할 수 있다.

        만약 p 나 a,b 가 너무 작을 경우, 도청자는 가능한 모든 조합을 계산하는 방식으로 s를 계산해 낼 수 있다. 
        따라서 큰 소수를 사용해야 한다.

        만약 p 가 최소 300자리의 소수이고, a 와 b 가 각각 100 자리 이상의 정수일 경우, 현재 인류가 보유한 모든 컴퓨터를 동원해도 공개된 정보로부터 비밀 키를 알아낼 수 없는것으로 알려져 잇다.
        앨리스와 밥이 충분히 안전하지 못한 난수 생성 알고리즘을 사용할 경우, 공격자는 이를 이용해 다음  a 와  b의 특성을 어느정도 예측할 수 있다.

        디피-헬먼 키 교환은 통신을 하는 대상과 비밀 정보를 공유할 수 있지만, 
        상대방에 대한 인증은 보장되지 않으며 중간자 공격이 가능하다. 
        Alice 와 Bob 이 상대방에 대한 인증을 하지 못할 경우, 공격자는 중간에서 통신을 가로채 Alice 와 공격자, 
        그리고 공격자와 Bob 사이에 각각 두 개의 디피 헬먼 키 교환을 생성하고, Alice 와 Bob이 각각 서로와 통신을 하는 것처럼 위장할 수 있다. 
        이와 같은 종류의 중간자 공격을 막기 위한 여러가지 다른 알고리즘이 개발되어 있다.
    
```

### 메시지 인증 코드 
```bash
    메시지 인증코드는 '인증' 과 '변조 검출' 의 두가지 기능을 가지는 구조이다.
    상황:
        알리스가 밥에게  공개키 암호방식 혹은 디피-헬먼 키 교환방법 등 키교환 프로토콜을 사용하여 
        암호화 키를 안전하게 전송 하였다고 하자.
        이후부터 공통키 암호방식을 사용하여 암호화된 메시지를 전송 한다.
        만약 알리스가 암호화한 암호문을 중간에서 공격자가 가로채어 변조 한 후 밥에게 전송 한다고 하자.
        밥은 변조된 상황을 눈치 채지 못하고 복호화 하여 메시지를 그대로 믿게 된다.
        이러한 변조를 감지 하려면 암호화하는 다른 수단이 필요하게 된다.
        이때 메시지 인증코드를 사용하면 메시지 변조를 감지 할수 있다.

        원리:
            알리스는 메시지 인증코드 작성을 위한 키를 생성 하여 안전한 방법(키교환 프로토콜 사용)을 사용하여 밥에게 전송 한다.
            알리스는 암호문과 해당 키를 사용하여 특정 값을 만든다. 이때 값을 메시지 인증코드 (MAC: message authentication code) 이라고 한다.
            이때 MAC 은 해시 값으로 보면 된다.
            알리스는 MAC 과 암호문을 밥에게 보낸다.
            밥은 전달받은 암호문과 키를 사용하여 MAC 을 생성 하여 알리스에게서 전달받은 MAC 과 비교 하여 변조 여부를 판단한다.
            이후로는 암호문용 키를 사용하여 복호화 하면 된다.

            즉 공격자가 중간에서 암호문을 변조 하면 MAC 이 변경되기 때문에 밥은 변조 됨을 알수있게된다.
            그런데 공격자가 암호문의 변조 내용에 맞게 MAC 또한 변조 하게 된다면? 
            공격자는 MAC 을 생성하기 위한 키를 가지고 있지 않기 때문에 MAC 을 변조 하였다고 하여도 암호문의 변조에 맞추는것은  불가능 하다.

            하지만 여기에도 문제가 있다.
            알리스와 밥 모두 가지고 있는 키로 메시지를 암호화 하고 MAC 을 생성 할 수 있다.
            즉 원 메시지를 작성한 것이 알리스인지 밥인지 증명 할 수 없게 된다.
            따라서 알리스가 악의를 지니고 메시지를 보낸 후 밥이 조작한 메시지다 라고 자신이 보낸것을 부인 해도 증명 할 수 없게 된다.
            이러한 부인 방지를 위해 '전자 서명' 을 사용해야 한다.

```

### 전자 서명
```bash
```

### 전자 인증서
```bash
```
